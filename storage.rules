rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    function isSignedIn() { return request.auth != null; }
    function tokenDoc(tokenId) {
      return firestore.get(/databases/(default)/documents/submissionUploadTokens/$(tokenId));
    }
    function submissionUserDoc(submissionId) {
      return firestore.get(/databases/(default)/documents/submissionUsers/$(submissionId));
    }
    function collabDoc(collabId) {
      return firestore.get(/databases/(default)/documents/collaborations/$(collabId));
    }
    function projectDoc(projectId) {
      return firestore.get(/databases/(default)/documents/projects/$(projectId));
    }
    function isCollabOwner(collabId) {
      return isSignedIn()
        && firestore.exists(/databases/(default)/documents/collaborations/$(collabId))
        && collabDoc(collabId).data.projectId is string
        && firestore.exists(/databases/(default)/documents/projects/$(collabDoc(collabId).data.projectId))
        && projectDoc(collabDoc(collabId).data.projectId).data.ownerId == request.auth.uid;
    }
    function isValidSubmissionToken(collabId, fileId) {
      return request.resource.metadata.uploadTokenId is string
        && request.resource.metadata.ownerUid is string
        && request.auth.uid == request.resource.metadata.ownerUid
        && firestore.exists(/databases/(default)/documents/submissionUploadTokens/$(request.resource.metadata.uploadTokenId))
        && tokenDoc(request.resource.metadata.uploadTokenId).data.collabId == collabId
        && tokenDoc(request.resource.metadata.uploadTokenId).data.uid == request.auth.uid
        && tokenDoc(request.resource.metadata.uploadTokenId).data.used == false
        && tokenDoc(request.resource.metadata.uploadTokenId).data.expiresAt > request.time
        && fileId.matches("^" + tokenDoc(request.resource.metadata.uploadTokenId).data.submissionId + "\\." + tokenDoc(request.resource.metadata.uploadTokenId).data.fileExt + "$");
    }
    function isValidMultitrackUpload(collabId, fileId) {
      return isValidMultitrackToken(collabId, fileId) || isValidMultitrackOwner(collabId, fileId);
    }
    function isValidMultitrackToken(collabId, fileId) {
      return request.resource.metadata.uploadTokenId is string
        && request.resource.metadata.ownerUid is string
        && request.auth.uid == request.resource.metadata.ownerUid
        && firestore.exists(/databases/(default)/documents/submissionUploadTokens/$(request.resource.metadata.uploadTokenId))
        && tokenDoc(request.resource.metadata.uploadTokenId).data.collabId == collabId
        && tokenDoc(request.resource.metadata.uploadTokenId).data.uid == request.auth.uid
        && tokenDoc(request.resource.metadata.uploadTokenId).data.expiresAt > request.time
        && fileId.matches("^" + tokenDoc(request.resource.metadata.uploadTokenId).data.submissionId + "-multitracks\\.zip$");
    }
    function isValidMultitrackOwner(collabId, fileId) {
      return request.resource.metadata.submissionId is string
        && request.resource.metadata.ownerUid is string
        && request.auth.uid == request.resource.metadata.ownerUid
        && fileId.matches("^" + request.resource.metadata.submissionId + "-multitracks\\.zip$")
        && firestore.exists(/databases/(default)/documents/submissionUsers/$(request.resource.metadata.submissionId))
        && submissionUserDoc(request.resource.metadata.submissionId).data.userId == request.auth.uid
        && submissionUserDoc(request.resource.metadata.submissionId).data.collaborationId == collabId;
    }

    // Public read for audio assets
    // Backing files live at: collabs/{collabId}/backing.{ext}
    // We match any file directly under collab and gate by filename
    match /collabs/{collabId}/{fileName} {
      allow read: if true;
      allow write: if isSignedIn()
        && fileName.matches('^backing\\..+$')
        && request.resource.contentType.matches('audio/.*')
        && request.resource.size < 131072000 // < 125MB
        && isCollabOwner(collabId);
    }

    match /collabs/{collabId}/submissions/{fileId} {
      allow read: if true;
      allow write: if isSignedIn()
        && (
          (request.resource.contentType.matches('audio/.*')
            && request.resource.size < 131072000
            && isValidSubmissionToken(collabId, fileId))
          || (fileId.matches('^.*-multitracks\\.zip$')
            && request.resource.size < 314572800
            && isValidMultitrackUpload(collabId, fileId))
        );
    }

    match /collabs/{collabId}/docs/{fileName} {
      allow read: if true;
      allow write: if isSignedIn()
        && (
          (fileName.matches('^.*\\.pdf$') && request.resource.size < 52428800)
          || (fileName.matches('^.*\\.zip$') && request.resource.size < 314572800)
        )
        && isCollabOwner(collabId);
    }

    // Optimized/transcoded submission files
    match /collabs/{collabId}/optimized/{fileId} {
      allow read: if true;
      allow write: if false;
    }

    // Default deny
    match /{allPaths=**} {
      allow read: if false;
      allow write: if false;
    }
  }
}
